 URL : "https://github.com/linchwei/blog/issues/15" TITLE : let 和 const 命令 BODY : let命令 基本用法 es6新增了 let 命令用来声明变量。用法类似于 var ，只是所声明的变量只在 let 命令所在的代码块内有效。 javascript { let a = 10; var b = 1; } a // referenceerror: a is not defined. b // 1 上面代码在代码块之中，分别用 let 和 var 声明了两个变量。然后在代码块之外调用这两个变量，结果 let 声明的变量报错， var 声明的变量反悔了正确的值。这表明， let 声明的变量只在它所在的代码块有效。 for 循环的计数器，就很适合使用 let 声明。 javascript for let i = 0; i < 10; i++ { // ... } console.log i // referenceerror: i is not defined 上面代码中，计数器 i 只在 for 循环体内有效，在循环体外引用就会报错。 下面的代码使用 var 最后输出的就是10： javascript var a = ; for var i = 0; i < 10; i++ { a i = function { console.log i ; } } a 6 ; // 10 上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i 。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log i ，里面的 i 指向的就是全局的 i 。也就是说，所有数组 a 的成员里面的 i ，指向的都是同一个 i ，导致运行时输出的是最后一轮的 i 的值，也就是 10 。 如果使用 let ，声明的变量仅在块级作用域内有效，最后输出的是 6 。 javascript var a = ; for let i = 0; i < 10; i++ { a i = function { console.log i ; }; } a 6 ; // 6 上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6 。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 javascript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外， for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 javascript for let i = 0; i < 3; i++ { let i = 'abc'; console.log i ; } // abc // abc // abc 上面代码正确运行，输出了3次 abc 。这表明函数内部的变量i与循环变量 i 不在同一个作用域，有各自单独的作用域。